{
  "metadata": {
    "id": "29c49486-998d-4f67-bfc0-83d6576859af",
    "name": "Automated Workflow",
    "icon_url": null,
    "description": null,
    "deployment_status": "DRAFT",
    "last_execution_status": null,
    "last_execution_time": null,
    "tags": [],
    "created_time": 1759470388800,
    "parent_workflow": null,
    "statistics": {
      "total_runs": 0,
      "average_duration_ms": 0,
      "total_credits": 0,
      "last_success_time": null
    },
    "version": "1.0",
    "created_by": "7ba36345-a2bb-4ec9-a001-bb46d79d629d",
    "updated_by": null
  },
  "nodes": [
    {
      "id": "github_trigger_1",
      "name": "github_trigger",
      "description": "Listens for issue events on the backend repository",
      "type": "TRIGGER",
      "subtype": "GITHUB",
      "configurations": {
        "events": [
          "issues"
        ],
        "enabled": true,
        "timeout": 120,
        "branches": [],
        "repository": "team/backend",
        "retry_attempts": 3,
        "webhook_secret": "",
        "include_payload": true,
        "filter_conditions": {}
      },
      "input_params": {},
      "output_params": {
        "branch": "",
        "sender": "",
        "commit_sha": "",
        "event_type": "",
        "repository": "",
        "trigger_time": "",
        "github_payload": {},
        "trigger_message": ""
      },
      "input_ports": [],
      "output_ports": [],
      "position": {
        "x": 100.0,
        "y": 100.0
      },
      "attached_nodes": null
    },
    {
      "id": "transform_extract_issue_1",
      "name": "extract_issue",
      "description": "Extracts title, creator, URL, and labels from the GitHub issue payload",
      "type": "ACTION",
      "subtype": "DATA_TRANSFORMATION",
      "configurations": {
        "enabled": true,
        "timeout": 30,
        "operation": "extract_fields",
        "sort_config": {},
        "field_mapping": {
          "url": "issue.html_url",
          "title": "issue.title",
          "labels": "issue.labels",
          "creator": "issue.user.login"
        },
        "output_format": "json",
        "retry_attempts": 2,
        "group_by_fields": [],
        "filter_conditions": [],
        "preserve_metadata": false,
        "aggregation_functions": {},
        "transformation_script": "def transform(payload):\n    issue = payload.get('issue', {})\n    return {'title': issue.get('title'), 'creator': issue.get('user', {}).get('login'), 'url': issue.get('html_url'), 'labels': issue.get('labels', [])}"
      },
      "input_params": {
        "data": [],
        "context": {},
        "variables": {}
      },
      "output_params": {
        "success": false,
        "output_count": 0,
        "error_message": "",
        "original_count": 0,
        "transformed_data": [],
        "transformation_stats": {}
      },
      "input_ports": [],
      "output_ports": [],
      "position": {
        "x": 300.0,
        "y": 100.0
      },
      "attached_nodes": null
    },
    {
      "id": "slack_post_message_1",
      "name": "slack_notification",
      "description": "Sends a Slack message to the backend channel with extracted issue details, mentions oncall, and lists labels",
      "type": "EXTERNAL_ACTION",
      "subtype": "SLACK",
      "configurations": {
        "channel": "#backend",
        "enabled": true,
        "timeout": 30,
        "bot_token": "xoxb-123456789012-9876543210-EXAMPLETOKEN",
        "thread_ts": "",
        "use_oauth": false,
        "action_type": "post_message",
        "unfurl_links": true,
        "unfurl_media": false,
        "message_format": "mrkdwn",
        "retry_attempts": 2
      },
      "input_params": {
        "blocks": [],
        "message": "",
        "metadata": {},
        "attachments": [],
        "user_mentions": [],
        "channel_override": ""
      },
      "output_params": {
        "success": false,
        "channel_id": "",
        "message_ts": "",
        "api_response": {},
        "error_message": "",
        "response_data": {}
      },
      "input_ports": [],
      "output_ports": [],
      "position": {
        "x": 500.0,
        "y": 100.0
      },
      "attached_nodes": null
    }
  ],
  "connections": [
    {
      "id": "github_to_transform",
      "from_node": "github_trigger_1",
      "to_node": "transform_extract_issue_1",
      "output_key": "result",
      "conversion_function": "def convert(input_data: Dict[str, Any]) -> Dict[str, Any]:\n    payload = input_data.get('data', input_data)\n    # Normalize to a list for uniform processing\n    items = payload if isinstance(payload, list) else [payload]\n    transformed = []\n    original_count = len(items)\n    for original in items:\n        if not isinstance(original, dict):\n            continue\n        # Unwrap possible wrapper keys (common patterns)\n        candidate = original\n        if 'github_payload' in candidate and isinstance(candidate['github_payload'], dict):\n            candidate = candidate['github_payload']\n        if 'payload' in candidate and isinstance(candidate['payload'], dict):\n            candidate = candidate['payload']\n        # Identify issue object\n        issue = candidate.get('issue')\n        # Some webhook payloads embed issue under other keys\n        if issue is None:\n            issue = candidate.get('action_payload') or None\n        action = (candidate.get('action') or original.get('action') or '').lower()\n        # Repository identification\n        repo_obj = candidate.get('repository') or original.get('repository') or {}\n        repo_name = ''\n        if isinstance(repo_obj, dict):\n            repo_name = repo_obj.get('full_name') or repo_obj.get('name') or ''\n        elif isinstance(repo_obj, str):\n            repo_name = repo_obj\n        repo_name = (repo_name or '').lower()\n        # Additional fallback: top-level event_type indicating 'issues'\n        event_type = (original.get('event_type') or candidate.get('event_type') or '').lower()\n        # Determine if this is a newly opened issue in a backend repo\n        is_issue_event = issue is not None or event_type == 'issues'\n        is_opened = action == 'opened' or action == 'open' or action == 'created'\n        is_backend_repo = False\n        if repo_name:\n            is_backend_repo = 'backend' in repo_name\n        else:\n            repo_field = original.get('repository') or ''\n            if isinstance(repo_field, str):\n                is_backend_repo = 'backend' in repo_field.lower()\n            elif isinstance(repo_field, dict):\n                name_try = repo_field.get('full_name') or repo_field.get('name') or ''\n                is_backend_repo = 'backend' in (name_try or '').lower()\n        if is_issue_event and is_opened and is_backend_repo:\n            # Robust extraction of fields\n            issue_obj = issue if isinstance(issue, dict) else candidate.get('issue', {}) if isinstance(candidate.get('issue', {}), dict) else {}\n            title = issue_obj.get('title', '') or ''\n            creator = (issue_obj.get('user', {}) or {}).get('login') or (original.get('sender', {}) or {}).get('login') or ''\n            url = issue_obj.get('html_url') or issue_obj.get('url') or ''\n            number = issue_obj.get('number')\n            trigger_message = 'New issue opened in {}: {}'.format(repo_name or original.get('repository', ''), title)\n            # Extract labels robustly from common locations\n            labels_raw = None\n            if 'labels' in issue_obj and isinstance(issue_obj.get('labels'), list):\n                labels_raw = issue_obj.get('labels')\n            elif 'labels' in candidate and isinstance(candidate.get('labels'), list):\n                labels_raw = candidate.get('labels')\n            elif 'labels' in original and isinstance(original.get('labels'), list):\n                labels_raw = original.get('labels')\n            else:\n                # Fallback: single label fields\n                if 'label' in issue_obj:\n                    labels_raw = [issue_obj.get('label')]\n                elif 'label' in candidate:\n                    labels_raw = [candidate.get('label')]\n            labels = []\n            if isinstance(labels_raw, list):\n                for lbl in labels_raw:\n                    if isinstance(lbl, str):\n                        name = lbl.strip()\n                        if name:\n                            labels.append(name)\n                    elif isinstance(lbl, dict):\n                        name = lbl.get('name') or lbl.get('label') or lbl.get('title') or ''\n                        if isinstance(name, str) and name.strip():\n                            labels.append(name.strip())\n            # Deduplicate preserving order\n            seen = set()\n            labels_unique = []\n            for l in labels:\n                if l not in seen:\n                    seen.add(l)\n                    labels_unique.append(l)\n            labels_text = ', '.join(labels_unique) if labels_unique else ''\n            labels_bulleted = '\\n'.join('- ' + l for l in labels_unique) if labels_unique else ''\n            item = {\n                'title': title,\n                'creator': creator,\n                'url': url,\n                'repository': repo_name or (repo_obj if isinstance(repo_obj, str) else ''),\n                'issue_number': number,\n                'trigger_message': trigger_message,\n                'github_payload': issue_obj,\n                'labels': labels_unique,\n                'labels_text': labels_text,\n                'labels_bulleted': labels_bulleted,\n                # Provide a helper for Slack conversion to prepend mention\n                'slack_mention': '@backend-oncall'\n            }\n            transformed.append(item)\n    output = {\n        'transformed_data': transformed,\n        'original_count': original_count,\n        'output_count': len(transformed),\n        'transformation_stats': {\n            'processed': original_count,\n            'matched': len(transformed)\n        },\n        'success': True if len(transformed) > 0 else False,\n        'error_message': '' if len(transformed) > 0 else ''\n    }\n    return output"
    },
    {
      "id": "transform_to_slack",
      "from_node": "transform_extract_issue_1",
      "to_node": "slack_post_message_1",
      "output_key": "result",
      "conversion_function": "def convert(input_data: Dict[str, Any]) -> Dict[str, Any]:\n    # locate primary payload\n    payload = input_data.get(\"data\")\n    if payload is None:\n        payload = input_data.get(\"value\")\n    if payload is None:\n        payload = input_data.get(\"output\", input_data)\n\n    # If payload is a list, prefer the first item\n    if isinstance(payload, list):\n        payload = payload[0] if payload else {}\n\n    if not isinstance(payload, dict):\n        payload = {}\n\n    # issue may be nested under \"issue\" or provided directly\n    issue = payload.get(\"issue\") if \"issue\" in payload else payload\n\n    # safe getter helper\n    def _get(d, *keys):\n        if not isinstance(d, dict):\n            return None\n        for k in keys:\n            v = d.get(k)\n            if v:\n                return v\n        return None\n\n    title = _get(issue, \"title\", \"issue_title\") or \"\"\n    url = _get(issue, \"html_url\", \"htmlUrl\", \"url\") or \"\"\n    number = _get(issue, \"number\") or \"\"\n    user = \"\"\n    if isinstance(issue, dict):\n        user = _get(issue.get(\"user\", {}), \"login\", \"name\") or _get(issue, \"creator\") or \"\"\n    if not user:\n        user = _get(payload.get(\"sender\", {}), \"login\", \"name\") or user\n\n    # repository name\n    repo = _get(payload.get(\"repository\", {}), \"name\") or _get(payload.get(\"repo\", {}), \"name\") or \"\"\n    if not repo and isinstance(issue, dict):\n        repo = _get(issue.get(\"repository\", {}), \"name\") or repo\n\n    # extract labels from various common locations and normalize to list of names\n    def _extract_labels_from_obj(obj):\n        if not isinstance(obj, dict):\n            return []\n        labels_val = obj.get(\"labels\") or []\n        result = []\n        if isinstance(labels_val, list):\n            for it in labels_val:\n                if isinstance(it, dict):\n                    name = it.get(\"name\") or it.get(\"title\") or it.get(\"label\")\n                    if name:\n                        result.append(str(name))\n                elif isinstance(it, str):\n                    result.append(it)\n        return result\n\n    labels = []\n    # check issue labels\n    labels = _extract_labels_from_obj(issue)\n    # fallback to payload-level labels\n    if not labels:\n        labels = _extract_labels_from_obj(payload)\n    # additional fallback: payload.get('issue', {}).get('labels')\n    if not labels and isinstance(payload.get(\"issue\"), dict):\n        labels = _extract_labels_from_obj(payload.get(\"issue\"))\n\n    # deduplicate preserving order\n    seen = set()\n    deduped = []\n    for l in labels:\n        if l not in seen:\n            seen.add(l)\n            deduped.append(l)\n    labels = deduped\n\n    labels_str = \", \".join(labels) if labels else \"\"\n    labels_bullets = \"\\n\".join([\"- \" + l for l in labels]) if labels else \"\"\n\n    # Build Slack mrkdwn message with @backend-oncall mention at top\n    parts = []\n    parts.append(\"@backend-oncall\")\n    parts.append(\"*New GitHub issue opened*\")\n    if repo:\n        parts.append(f\"*Repository:* {repo}\")\n    if number:\n        parts.append(f\"*Issue:* #{number}\")\n    if title:\n        parts.append(f\"*Title:* {title}\")\n    if user:\n        parts.append(f\"*Opened by:* {user}\")\n    if labels_str:\n        parts.append(f\"*Labels:* {labels_str}\")\n        # include bullet list for readability\n        parts.append(labels_bullets)\n    if url:\n        parts.append(url)\n\n    message_text = \"\\n\".join(parts) if parts else \"A new GitHub issue was opened.\"\n\n    result = {\n        \"action_type\": \"send_message\",\n        \"channel\": \"#backend\",\n        \"message_format\": \"mrkdwn\",\n        \"message\": message_text,\n        \"metadata\": {\n            \"source\": \"github\",\n            \"extracted\": {\n                \"title\": title,\n                \"number\": number,\n                \"user\": user,\n                \"url\": url,\n                \"repository\": repo,\n                \"labels\": labels\n            }\n        }\n    }\n\n    return result"
    }
  ],
  "triggers": [
    "github_trigger_1"
  ]
}