# èŠ‚ç‚¹è§„èŒƒç³»ç»ŸæŠ€æœ¯è®¾è®¡

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£æè¿°äº†å·¥ä½œæµå¼•æ“èŠ‚ç‚¹è§„èŒƒç³»ç»Ÿçš„æŠ€æœ¯è®¾è®¡ã€‚è¯¥ç³»ç»Ÿè§£å†³äº†å½“å‰èŠ‚ç‚¹ç±»å‹å’Œå­ç±»å‹ä»…ä»¥æšä¸¾å½¢å¼å®šä¹‰ï¼Œç¼ºä¹å‚æ•°æ¨¡å¼ã€è¾“å…¥è¾“å‡ºç«¯å£å®šä¹‰å’ŒéªŒè¯è§„åˆ™çš„é—®é¢˜ã€‚

èŠ‚ç‚¹è§„èŒƒç³»ç»Ÿæ˜¯å·¥ä½œæµå¼•æ“çš„æ ¸å¿ƒæ¶æ„ç»„ä»¶ï¼Œå®ƒç»Ÿä¸€ç®¡ç†:
- **èŠ‚ç‚¹ç±»å‹å®šä¹‰**: æ¯ä¸ªèŠ‚ç‚¹ç±»å‹çš„å‚æ•°ã€ç«¯å£ã€éªŒè¯è§„åˆ™
- **ç«¯å£ç³»ç»Ÿ**: è¾“å…¥è¾“å‡ºç«¯å£çš„ç±»å‹å®‰å…¨å’Œè¿æ¥éªŒè¯
- **æ•°æ®æ ¼å¼è§„èŒƒ**: ç«¯å£é—´æ•°æ®ä¼ è¾“çš„ç»“æ„åŒ–å®šä¹‰
- **å‚æ•°éªŒè¯**: èŠ‚ç‚¹é…ç½®çš„å®Œæ•´æ€§æ£€æŸ¥

## ğŸ¯ é—®é¢˜æè¿°

### å½“å‰é—®é¢˜
1. **ç¼ºå¤±å‚æ•°æ¨¡å¼**: æ²¡æœ‰æ­£å¼å®šä¹‰æ¯ä¸ªèŠ‚ç‚¹ç±»å‹éœ€è¦ä»€ä¹ˆå‚æ•°
2. **æœªå®šä¹‰ç«¯å£è§„èŒƒ**: æ¯ä¸ªèŠ‚ç‚¹çš„è¾“å…¥è¾“å‡ºç«¯å£å®šä¹‰ä¸æ¸…æ™°
3. **ç¼ºä¹ç«¯å£ç±»å‹å®‰å…¨**: èŠ‚ç‚¹è¿æ¥æ—¶æ— æ³•éªŒè¯ç«¯å£ç±»å‹å…¼å®¹æ€§
4. **ç¼ºä¹éªŒè¯**: å¯¹èŠ‚ç‚¹é…ç½®æ²¡æœ‰ç±»å‹æ£€æŸ¥æˆ–éªŒè¯
5. **å¼€å‘ä½“éªŒå·®**: æ²¡æœ‰è‡ªåŠ¨è¡¥å…¨æˆ–å‚æ•°æ–‡æ¡£
6. **å®ç°ä¸ä¸€è‡´**: Protocol Bufferå®šä¹‰ä¸å®é™…æ‰§è¡Œå™¨å®ç°ä¸åŒ¹é…
7. **æ•°æ®æ˜ å°„ç¼ºå¤±**: æ— æ³•å®šä¹‰èŠ‚ç‚¹é—´æ•°æ®å¦‚ä½•è½¬æ¢å’ŒéªŒè¯

### å½“å‰çŠ¶æ€ç¤ºä¾‹
```python
# ç›®å‰èŠ‚ç‚¹é…ç½®æ–¹å¼ï¼Œæ²¡æœ‰ä»»ä½•éªŒè¯
node.parameters = {
    "code": "print('hello')",      # æ— ç±»å‹æ£€æŸ¥
    "language": "python",          # æ— æšä¸¾éªŒè¯
    "timeout": "invalid_value"     # æ— æ ¼å¼éªŒè¯
}
```

## ğŸ—ï¸ è§£å†³æ–¹æ¡ˆ

### åŸºäºä»£ç çš„è§„èŒƒç³»ç»Ÿ
æˆ‘ä»¬æå‡º**åŸºäºä»£ç **çš„æ–¹æ¡ˆï¼Œå°†æ‰€æœ‰èŠ‚ç‚¹è§„èŒƒå®šä¹‰ä¸ºå…±äº«ä»£ç åº“ä¸­çš„Pythonç±»ï¼Œè€Œä¸æ˜¯å­˜å‚¨åœ¨æ•°æ®åº“ä¸­ã€‚

#### ä¸ºä»€ä¹ˆé€‰æ‹©åŸºäºä»£ç ï¼Ÿ
- **ç‰ˆæœ¬æ§åˆ¶**: æ‰€æœ‰å˜æ›´åœ¨Gitä¸­è·Ÿè¸ªï¼Œæœ‰å®Œæ•´çš„ä»£ç å®¡æŸ¥æµç¨‹
- **ç±»å‹å®‰å…¨**: å®Œæ•´çš„Pythonç±»å‹æç¤ºå’ŒIDEæ”¯æŒ
- **æ€§èƒ½**: å¯åŠ¨æ—¶åŠ è½½ä¸€æ¬¡ï¼Œè¿è¡Œæ—¶ä»å†…å­˜è®¿é—®
- **ç®€å•æ€§**: æ— éœ€æ•°æ®åº“ä¾èµ–
- **å¼€å‘ä½“éªŒ**: è‡ªåŠ¨è¡¥å…¨å’Œå†…è”æ–‡æ¡£

## ğŸ›ï¸ æ¶æ„è®¾è®¡

### ç›®å½•ç»“æ„
```
apps/backend/shared/node_specs/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ base.py                    # åŸºç¡€è§„èŒƒç±»
â”œâ”€â”€ registry.py                # ä¸­å¤®è§„èŒƒæ³¨å†Œå™¨
â”œâ”€â”€ validator.py               # è§„èŒƒéªŒè¯é€»è¾‘
â””â”€â”€ definitions/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ trigger_nodes.py       # è§¦å‘å™¨èŠ‚ç‚¹è§„èŒƒ
    â”œâ”€â”€ ai_agent_nodes.py      # AIä»£ç†èŠ‚ç‚¹è§„èŒƒ
    â”œâ”€â”€ action_nodes.py        # åŠ¨ä½œèŠ‚ç‚¹è§„èŒƒ
    â”œâ”€â”€ flow_nodes.py          # æµç¨‹æ§åˆ¶èŠ‚ç‚¹è§„èŒƒ
    â”œâ”€â”€ tool_nodes.py          # å·¥å…·èŠ‚ç‚¹è§„èŒƒ
    â”œâ”€â”€ memory_nodes.py        # è®°å¿†èŠ‚ç‚¹è§„èŒƒ
    â””â”€â”€ human_loop_nodes.py    # äººæœºäº¤äº’èŠ‚ç‚¹è§„èŒƒ
```

### æ ¸å¿ƒæ•°æ®ç»“æ„

#### åŸºç¡€è§„èŒƒç±»
```python
@dataclass
class ParameterDef:
    name: str
    type: ParameterType
    required: bool = False
    default_value: Optional[str] = None
    enum_values: Optional[List[str]] = None
    description: str = ""
    validation_pattern: Optional[str] = None

@dataclass
class InputPortSpec:
    name: str
    type: str                    # ConnectionType (MAIN, AI_TOOL, AI_MEMORY, etc.)
    required: bool = False
    description: str = ""
    max_connections: int = 1     # æœ€å¤§è¿æ¥æ•°ï¼Œ-1è¡¨ç¤ºæ— é™åˆ¶
    data_format: Optional[DataFormat] = None
    validation_schema: Optional[str] = None  # JSON Schema for validation

@dataclass
class OutputPortSpec:
    name: str
    type: str                    # ConnectionType
    description: str = ""
    max_connections: int = -1    # -1 = æ— é™åˆ¶
    data_format: Optional[DataFormat] = None
    validation_schema: Optional[str] = None  # JSON Schema for validation

@dataclass
class NodeSpec:
    node_type: str
    subtype: str
    version: str = "1.0.0"
    description: str = ""
    parameters: List[ParameterDef] = None
    input_ports: List[InputPortSpec] = None
    output_ports: List[OutputPortSpec] = None
    examples: Optional[List[Dict[str, Any]]] = None
```

#### å‚æ•°ç±»å‹
```python
class ParameterType(Enum):
    STRING = "string"
    INTEGER = "integer"
    FLOAT = "float"
    BOOLEAN = "boolean"
    ENUM = "enum"
    JSON = "json"
    FILE = "file"
    URL = "url"
    EMAIL = "email"
    CRON_EXPRESSION = "cron"
```

#### æ•°æ®æ ¼å¼è§„èŒƒ
```python
@dataclass
class DataFormat:
    mime_type: str = "application/json"
    schema: Optional[str] = None        # JSON Schemaï¼ˆå·²åŒ…å«requiredå­—æ®µå®šä¹‰ï¼‰
    examples: Optional[List[str]] = None

@dataclass
class ConnectionSpec:
    """è¿æ¥è§„èŒƒï¼Œå®šä¹‰ä¸¤ä¸ªç«¯å£é—´çš„æ•°æ®æ˜ å°„è§„åˆ™"""
    source_port: str
    target_port: str
    connection_type: str             # ConnectionType
    data_mapping: Optional['DataMappingSpec'] = None
    validation_required: bool = True

@dataclass
class DataMappingSpec:
    """æ•°æ®æ˜ å°„è§„èŒƒï¼Œå®šä¹‰ç«¯å£é—´æ•°æ®è½¬æ¢è§„åˆ™"""
    mapping_type: str                # DIRECT, FIELD_MAPPING, TEMPLATE, TRANSFORM
    field_mappings: Optional[List['FieldMappingSpec']] = None
    transform_script: Optional[str] = None
    static_values: Optional[Dict[str, str]] = None
    description: str = ""

@dataclass
class FieldMappingSpec:
    """å­—æ®µæ˜ å°„è§„èŒƒ"""
    source_field: str                # JSONPathæ ¼å¼çš„æºå­—æ®µè·¯å¾„
    target_field: str                # ç›®æ ‡å­—æ®µè·¯å¾„
    required: bool = False
    default_value: Optional[str] = None
    transform: Optional['FieldTransformSpec'] = None

@dataclass
class FieldTransformSpec:
    """å­—æ®µè½¬æ¢è§„èŒƒ"""
    type: str                        # NONE, STRING_FORMAT, FUNCTION, CONDITION, REGEX
    transform_value: str
    options: Optional[Dict[str, str]] = None
```

## ğŸ“ è§„èŒƒç¤ºä¾‹

### AIä»£ç†è·¯ç”±å™¨è§„èŒƒ
```python
ROUTER_AGENT_SPEC = NodeSpec(
    node_type="AI_AGENT_NODE",
    subtype="ROUTER_AGENT",
    description="æ™ºèƒ½è·¯ç”±ä»£ç†ï¼Œæ ¹æ®è¾“å…¥å†³å®šä¸‹ä¸€æ­¥æ“ä½œ",
    parameters=[
        ParameterDef(
            name="prompt",
            type=ParameterType.STRING,
            required=True,
            description="è·¯ç”±å†³ç­–çš„ç³»ç»Ÿæç¤ºè¯"
        ),
        ParameterDef(
            name="routing_options",
            type=ParameterType.JSON,
            required=True,
            description="å¯é€‰çš„è·¯ç”±é€‰é¡¹é…ç½®"
        ),
        ParameterDef(
            name="temperature",
            type=ParameterType.FLOAT,
            required=False,
            default_value="0.7",
            description="AIæ¨¡å‹çš„éšæœºæ€§æ§åˆ¶"
        )
    ],
    input_ports=[
        InputPortSpec(
            name="main",
            type="MAIN",
            required=True,
            description="å¾…è·¯ç”±çš„è¾“å…¥æ•°æ®",
            data_format=DataFormat(
                mime_type="application/json",
                schema='{"user_message": "string", "context": "object"}',
                examples=['{"user_message": "å¸®æˆ‘å®‰æ’ä¼šè®®", "context": {"user_id": "123"}}']
            ),
            validation_schema='{"type": "object", "properties": {"user_message": {"type": "string"}, "context": {"type": "object"}}, "required": ["user_message"]}'
        ),
        InputPortSpec(
            name="language_model",
            type="AI_LANGUAGE_MODEL",
            required=True,
            description="è¯­è¨€æ¨¡å‹è¿æ¥"
        )
    ],
    output_ports=[
        OutputPortSpec(
            name="main",
            type="MAIN",
            description="è·¯ç”±å†³ç­–ç»“æœ",
            data_format=DataFormat(
                mime_type="application/json",
                schema='{"route": "string", "confidence": "number", "reasoning": "string"}'
            ),
            validation_schema='{"type": "object", "properties": {"route": {"type": "string"}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "reasoning": {"type": "string"}}, "required": ["route", "confidence"]}'
        ),
        OutputPortSpec(
            name="error",
            type="MAIN",
            description="è·¯ç”±å¤±è´¥æ—¶çš„é”™è¯¯ä¿¡æ¯"
        )
    ]
)
```

### è§¦å‘å™¨èŠ‚ç‚¹è§„èŒƒ
```python
CRON_TRIGGER_SPEC = NodeSpec(
    node_type="TRIGGER_NODE",
    subtype="CRON",
    description="åŸºäºCronè¡¨è¾¾å¼çš„å®šæ—¶è§¦å‘å™¨",
    parameters=[
        ParameterDef(
            name="cron_expression",
            type=ParameterType.CRON_EXPRESSION,
            required=True,
            description="Cronæ—¶é—´è¡¨è¾¾å¼",
            validation_pattern=r"^(\*|[0-9,\-/]+)\s+(\*|[0-9,\-/]+)\s+(\*|[0-9,\-/]+)\s+(\*|[0-9,\-/]+)\s+(\*|[0-9,\-/]+)$"
        ),
        ParameterDef(
            name="timezone",
            type=ParameterType.STRING,
            required=False,
            default_value="UTC",
            description="æ—¶åŒºè®¾ç½®"
        )
    ],
    input_ports=[],  # è§¦å‘å™¨èŠ‚ç‚¹æ²¡æœ‰è¾“å…¥ç«¯å£
    output_ports=[
        OutputPortSpec(
            name="main",
            type="MAIN",
            description="å®šæ—¶è§¦å‘çš„è¾“å‡ºæ•°æ®",
            data_format=DataFormat(
                mime_type="application/json",
                schema='{"trigger_time": "string", "execution_id": "string"}'
            )
        )
    ]
)
```

### æµç¨‹æ§åˆ¶èŠ‚ç‚¹è§„èŒƒ
```python
IF_NODE_SPEC = NodeSpec(
    node_type="FLOW_NODE",
    subtype="IF",
    description="æ¡ä»¶åˆ¤æ–­èŠ‚ç‚¹ï¼Œæ ¹æ®æ¡ä»¶é€‰æ‹©æ‰§è¡Œåˆ†æ”¯",
    parameters=[
        ParameterDef(
            name="condition",
            type=ParameterType.STRING,
            required=True,
            description="åˆ¤æ–­æ¡ä»¶è¡¨è¾¾å¼"
        ),
        ParameterDef(
            name="condition_type",
            type=ParameterType.ENUM,
            required=False,
            default_value="javascript",
            enum_values=["javascript", "python", "jsonpath"],
            description="æ¡ä»¶è¡¨è¾¾å¼ç±»å‹"
        )
    ],
    input_ports=[
        InputPortSpec(
            name="main",
            type="MAIN",
            required=True,
            description="æ¡ä»¶åˆ¤æ–­çš„è¾“å…¥æ•°æ®"
        )
    ],
    output_ports=[
        OutputPortSpec(
            name="true",
            type="MAIN",
            description="æ¡ä»¶ä¸ºçœŸæ—¶çš„è¾“å‡º"
        ),
        OutputPortSpec(
            name="false",
            type="MAIN",
            description="æ¡ä»¶ä¸ºå‡æ—¶çš„è¾“å‡º"
        )
    ]
)
```

## ğŸ”§ æ³¨å†Œå™¨ç³»ç»Ÿ

### ä¸­å¤®æ³¨å†Œå™¨
```python
class NodeSpecRegistry:
    def __init__(self):
        self._specs: Dict[str, NodeSpec] = {}
        self._port_compatibility_cache: Dict[str, bool] = {}
        self._load_all_specs()

    def get_spec(self, node_type: str, subtype: str) -> Optional[NodeSpec]:
        """è·å–èŠ‚ç‚¹è§„èŒƒ"""
        key = f"{node_type}.{subtype}"
        return self._specs.get(key)

    def get_specs_by_type(self, node_type: str) -> List[NodeSpec]:
        """è·å–æŒ‡å®šç±»å‹çš„æ‰€æœ‰è§„èŒƒ"""
        return [spec for spec in self._specs.values() if spec.node_type == node_type]

    def validate_node(self, node) -> List[str]:
        """éªŒè¯èŠ‚ç‚¹é…ç½®"""
        spec = self.get_spec(node.type, node.subtype)
        if not spec:
            return [f"æœªçŸ¥èŠ‚ç‚¹ç±»å‹: {node.type}.{node.subtype}"]

        return self._validate_against_spec(node, spec)

    def validate_connection(self, source_node, source_port: str,
                          target_node, target_port: str) -> List[str]:
        """éªŒè¯ç«¯å£è¿æ¥å…¼å®¹æ€§"""
        errors = []

        source_spec = self.get_spec(source_node.type, source_node.subtype)
        target_spec = self.get_spec(target_node.type, target_node.subtype)

        if not source_spec or not target_spec:
            return ["æ— æ³•æ‰¾åˆ°èŠ‚ç‚¹è§„èŒƒè¿›è¡Œè¿æ¥éªŒè¯"]

        # æŸ¥æ‰¾æºè¾“å‡ºç«¯å£
        source_output_port = None
        for port in source_spec.output_ports:
            if port.name == source_port:
                source_output_port = port
                break

        if not source_output_port:
            errors.append(f"æºèŠ‚ç‚¹ {source_node.id} æ²¡æœ‰è¾“å‡ºç«¯å£ '{source_port}'")
            return errors

        # æŸ¥æ‰¾ç›®æ ‡è¾“å…¥ç«¯å£
        target_input_port = None
        for port in target_spec.input_ports:
            if port.name == target_port:
                target_input_port = port
                break

        if not target_input_port:
            errors.append(f"ç›®æ ‡èŠ‚ç‚¹ {target_node.id} æ²¡æœ‰è¾“å…¥ç«¯å£ '{target_port}'")
            return errors

        # éªŒè¯ç«¯å£ç±»å‹å…¼å®¹æ€§
        if source_output_port.type != target_input_port.type:
            errors.append(f"ç«¯å£ç±»å‹ä¸å…¼å®¹: {source_output_port.type} -> {target_input_port.type}")

        return errors

    def get_port_spec(self, node_type: str, subtype: str,
                     port_name: str, port_direction: str) -> Optional[Union[InputPortSpec, OutputPortSpec]]:
        """è·å–ç‰¹å®šç«¯å£çš„è§„èŒƒ"""
        spec = self.get_spec(node_type, subtype)
        if not spec:
            return None

        ports = spec.input_ports if port_direction == "input" else spec.output_ports
        for port in ports:
            if port.name == port_name:
                return port

        return None

# å…¨å±€å•ä¾‹å®ä¾‹
node_spec_registry = NodeSpecRegistry()
```

### éªŒè¯ç³»ç»Ÿ
```python
class NodeSpecValidator:
    @staticmethod
    def validate_parameters(node, spec: NodeSpec) -> List[str]:
        """éªŒè¯èŠ‚ç‚¹å‚æ•°"""
        errors = []

        # æ£€æŸ¥å¿…éœ€å‚æ•°
        for param_def in spec.parameters:
            if param_def.required and param_def.name not in node.parameters:
                errors.append(f"ç¼ºå°‘å¿…éœ€å‚æ•°: {param_def.name}")
                continue

            # éªŒè¯å‚æ•°ç±»å‹å’Œæ ¼å¼
            if param_def.name in node.parameters:
                value = node.parameters[param_def.name]
                param_errors = NodeSpecValidator._validate_parameter_value(value, param_def)
                errors.extend(param_errors)

        return errors

    @staticmethod
    def validate_ports(node, spec: NodeSpec) -> List[str]:
        """éªŒè¯èŠ‚ç‚¹ç«¯å£é…ç½®"""
        errors = []

        # éªŒè¯è¾“å…¥ç«¯å£
        required_inputs = {p.name for p in spec.input_ports if p.required}
        actual_inputs = {p.name for p in getattr(node, 'input_ports', [])}

        missing_inputs = required_inputs - actual_inputs
        for missing in missing_inputs:
            errors.append(f"ç¼ºå°‘å¿…éœ€çš„è¾“å…¥ç«¯å£: {missing}")

        # éªŒè¯è¾“å‡ºç«¯å£
        expected_outputs = {p.name for p in spec.output_ports}
        actual_outputs = {p.name for p in getattr(node, 'output_ports', [])}

        missing_outputs = expected_outputs - actual_outputs
        for missing in missing_outputs:
            errors.append(f"ç¼ºå°‘é¢„æœŸçš„è¾“å‡ºç«¯å£: {missing}")

        return errors

    @staticmethod
    def validate_port_data(port_spec: Union[InputPortSpec, OutputPortSpec],
                          data: Dict[str, Any]) -> List[str]:
        """éªŒè¯ç«¯å£æ•°æ®æ ¼å¼"""
        errors = []

        if port_spec.validation_schema:
            try:
                import jsonschema
                import json

                schema = json.loads(port_spec.validation_schema)
                jsonschema.validate(data, schema)
            except jsonschema.ValidationError as e:
                errors.append(f"æ•°æ®æ ¼å¼éªŒè¯å¤±è´¥: {e.message}")
            except Exception as e:
                errors.append(f"SchemaéªŒè¯é”™è¯¯: {str(e)}")

        # å¿…éœ€å­—æ®µéªŒè¯å·²åŒ…å«åœ¨validation_schemaä¸­ï¼Œæ­¤å¤„ä¸éœ€è¦é‡å¤æ£€æŸ¥

        return errors

    @staticmethod
    def _has_field(data: Dict[str, Any], field_path: str) -> bool:
        """æ£€æŸ¥æ•°æ®ä¸­æ˜¯å¦å­˜åœ¨æŒ‡å®šå­—æ®µ"""
        try:
            keys = field_path.split('.')
            current = data
            for key in keys:
                if isinstance(current, dict) and key in current:
                    current = current[key]
                else:
                    return False
            return True
        except:
            return False

    @staticmethod
    def _validate_parameter_value(value: str, param_def: ParameterDef) -> List[str]:
        """éªŒè¯å‚æ•°å€¼"""
        errors = []

        if param_def.type == ParameterType.INTEGER:
            try:
                int(value)
            except ValueError:
                errors.append(f"å‚æ•° {param_def.name} å¿…é¡»æ˜¯æ•´æ•°")

        elif param_def.type == ParameterType.FLOAT:
            try:
                float(value)
            except ValueError:
                errors.append(f"å‚æ•° {param_def.name} å¿…é¡»æ˜¯æµ®ç‚¹æ•°")

        elif param_def.type == ParameterType.BOOLEAN:
            if value.lower() not in ['true', 'false', '1', '0']:
                errors.append(f"å‚æ•° {param_def.name} å¿…é¡»æ˜¯å¸ƒå°”å€¼")

        elif param_def.type == ParameterType.ENUM:
            if param_def.enum_values and value not in param_def.enum_values:
                errors.append(f"å‚æ•° {param_def.name} å¿…é¡»æ˜¯ä»¥ä¸‹å€¼ä¹‹ä¸€: {param_def.enum_values}")

        elif param_def.type == ParameterType.JSON:
            try:
                import json
                json.loads(value)
            except json.JSONDecodeError:
                errors.append(f"å‚æ•° {param_def.name} å¿…é¡»æ˜¯æœ‰æ•ˆçš„JSON")

        # éªŒè¯æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼
        if param_def.validation_pattern:
            import re
            if not re.match(param_def.validation_pattern, value):
                errors.append(f"å‚æ•° {param_def.name} æ ¼å¼ä¸æ­£ç¡®")

        return errors
```

## ğŸ”— é›†æˆç‚¹

### Protocol Buffer Schemaæ›´æ–°

ä¸ºäº†æ”¯æŒç»Ÿä¸€çš„ç«¯å£ç³»ç»Ÿï¼Œéœ€è¦æ›´æ–° `apps/backend/shared/proto/engine/workflow.proto`:

```protobuf
// ç«¯å£å®šä¹‰ - åŸºäºNodeSpecç”Ÿæˆ
message InputPort {
  string name = 1;           // ç«¯å£åç§°
  string type = 2;           // ConnectionType
  bool required = 3;         // æ˜¯å¦å¿…éœ€
  string description = 4;    // ç«¯å£æè¿°
  int32 max_connections = 5; // æœ€å¤§è¿æ¥æ•°
  string validation_schema = 6; // JSON SchemaéªŒè¯
}

message OutputPort {
  string name = 1;           // ç«¯å£åç§°
  string type = 2;           // ConnectionType
  string description = 3;    // ç«¯å£æè¿°
  int32 max_connections = 4; // æœ€å¤§è¿æ¥æ•°
  string validation_schema = 5; // JSON SchemaéªŒè¯
}

// å¢å¼ºçš„èŠ‚ç‚¹å®šä¹‰
message Node {
  string id = 1;
  string name = 2;
  NodeType type = 3;
  NodeSubtype subtype = 4;
  int32 type_version = 5;
  Position position = 6;
  bool disabled = 7;
  map<string, string> parameters = 8;
  map<string, string> credentials = 9;
  ErrorHandling on_error = 10;
  RetryPolicy retry_policy = 11;
  map<string, string> notes = 12;
  repeated string webhooks = 13;

  // ç«¯å£å®šä¹‰ - åŸºäºNodeSpecè‡ªåŠ¨ç”Ÿæˆ
  repeated InputPort input_ports = 14;
  repeated OutputPort output_ports = 15;
}

// å¢å¼ºçš„è¿æ¥å®šä¹‰ - æ”¯æŒæ•°æ®æ˜ å°„
message Connection {
  string node = 1;              // ç›®æ ‡èŠ‚ç‚¹å
  ConnectionType type = 2;      // è¿æ¥ç±»å‹
  int32 index = 3;             // ç«¯å£ç´¢å¼•ï¼ˆå‘åå…¼å®¹ï¼‰
  string source_port = 4;      // æºç«¯å£åç§°
  string target_port = 5;      // ç›®æ ‡ç«¯å£åç§°
  DataMapping data_mapping = 6; // æ•°æ®æ˜ å°„è§„åˆ™
}

// æ•°æ®æ˜ å°„å®šä¹‰
message DataMapping {
  MappingType type = 1;
  repeated FieldMapping field_mappings = 2;
  string transform_script = 3;
  map<string, string> static_values = 4;
  string description = 5;
}

enum MappingType {
  DIRECT = 0;
  FIELD_MAPPING = 1;
  TEMPLATE = 2;
  TRANSFORM = 3;
}

message FieldMapping {
  string source_field = 1;
  string target_field = 2;
  FieldTransform transform = 3;
  bool required = 4;
  string default_value = 5;
}

message FieldTransform {
  TransformType type = 1;
  string transform_value = 2;
  map<string, string> options = 3;
}

enum TransformType {
  NONE = 0;
  STRING_FORMAT = 1;
  JSON_PATH = 2;
  REGEX = 3;
  FUNCTION = 4;
  CONDITION = 5;
}
```

### å·¥ä½œæµå¼•æ“é›†æˆ
```python
# åœ¨BaseNodeExecutorä¸­
class BaseNodeExecutor(ABC):
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.spec = self._get_node_spec()

    def _get_node_spec(self) -> Optional[NodeSpec]:
        """è·å–æ­¤æ‰§è¡Œå™¨çš„è§„èŒƒ"""
        # æ´¾ç”Ÿç±»åº”è¯¥å®ç°æ­¤æ–¹æ³•æˆ–ä½¿ç”¨æ³¨å†Œå™¨
        return None

    def validate(self, node: Any) -> List[str]:
        """æ ¹æ®è§„èŒƒéªŒè¯èŠ‚ç‚¹"""
        if self.spec:
            return node_spec_registry.validate_node(node)
        return []

    def get_input_port_specs(self) -> List[InputPortSpec]:
        """è·å–è¾“å…¥ç«¯å£è§„èŒƒ"""
        return self.spec.input_ports if self.spec else []

    def get_output_port_specs(self) -> List[OutputPortSpec]:
        """è·å–è¾“å‡ºç«¯å£è§„èŒƒ"""
        return self.spec.output_ports if self.spec else []

    def validate_input_data(self, port_name: str, data: Dict[str, Any]) -> List[str]:
        """éªŒè¯è¾“å…¥ç«¯å£æ•°æ®"""
        if not self.spec:
            return []

        port_spec = None
        for port in self.spec.input_ports:
            if port.name == port_name:
                port_spec = port
                break

        if not port_spec:
            return [f"æœªçŸ¥è¾“å…¥ç«¯å£: {port_name}"]

        return NodeSpecValidator.validate_port_data(port_spec, data)

# åœ¨å…·ä½“æ‰§è¡Œå™¨ä¸­
class AIAgentNodeExecutor(BaseNodeExecutor):
    def __init__(self, node_subtype: str):
        self.node_subtype = node_subtype
        super().__init__()

    def _get_node_spec(self) -> Optional[NodeSpec]:
        return node_spec_registry.get_spec("AI_AGENT_NODE", self.node_subtype)
```

### è¿æ¥éªŒè¯å™¨å¢å¼º
```python
class WorkflowValidator:
    def __init__(self):
        self.node_registry = node_spec_registry
        self.data_mapper = DataMappingProcessor()

    def validate_workflow(self, workflow) -> List[str]:
        """éªŒè¯å®Œæ•´å·¥ä½œæµ"""
        errors = []

        # éªŒè¯èŠ‚ç‚¹é…ç½®
        for node in workflow.nodes:
            node_errors = self.validate_node(node)
            errors.extend(node_errors)

        # éªŒè¯è¿æ¥
        connection_errors = self.validate_connections(workflow)
        errors.extend(connection_errors)

        return errors

    def validate_node(self, node) -> List[str]:
        """éªŒè¯å•ä¸ªèŠ‚ç‚¹"""
        return self.node_registry.validate_node(node)

    def validate_connections(self, workflow) -> List[str]:
        """éªŒè¯èŠ‚ç‚¹è¿æ¥"""
        errors = []

        for node_name, node_connections in workflow.connections.connections.items():
            source_node = self._find_node_by_name(workflow.nodes, node_name)
            if not source_node:
                continue

            for connection_type, connection_array in node_connections.connection_types.items():
                for connection in connection_array.connections:
                    target_node = self._find_node_by_name(workflow.nodes, connection.node)
                    if not target_node:
                        errors.append(f"è¿æ¥ç›®æ ‡èŠ‚ç‚¹ä¸å­˜åœ¨: {connection.node}")
                        continue

                    # éªŒè¯ç«¯å£è¿æ¥
                    source_port = getattr(connection, 'source_port', 'main')
                    target_port = getattr(connection, 'target_port', 'main')

                    port_errors = self.node_registry.validate_connection(
                        source_node, source_port, target_node, target_port
                    )
                    errors.extend(port_errors)

                    # éªŒè¯æ•°æ®æ˜ å°„
                    if hasattr(connection, 'data_mapping') and connection.data_mapping:
                        mapping_errors = self._validate_data_mapping(
                            source_node, target_node, connection.data_mapping
                        )
                        errors.extend(mapping_errors)

        return errors

    def _validate_data_mapping(self, source_node, target_node, data_mapping) -> List[str]:
        """éªŒè¯æ•°æ®æ˜ å°„é…ç½®"""
        errors = []

        # è¿™é‡Œå¯ä»¥æ·»åŠ æ•°æ®æ˜ å°„è§„åˆ™çš„éªŒè¯é€»è¾‘
        # ä¾‹å¦‚éªŒè¯å­—æ®µè·¯å¾„ã€è½¬æ¢è„šæœ¬è¯­æ³•ç­‰

        return errors
```

### APIç½‘å…³é›†æˆ
```python
@router.get("/node-types")
async def get_node_types():
    """è·å–æ‰€æœ‰èŠ‚ç‚¹ç±»å‹å’Œå­ç±»å‹"""
    result = {}
    for spec in node_spec_registry.list_all_specs():
        if spec.node_type not in result:
            result[spec.node_type] = []
        result[spec.node_type].append({
            "subtype": spec.subtype,
            "description": spec.description
        })
    return result

@router.get("/node-types/{node_type}/{subtype}/spec")
async def get_node_spec(node_type: str, subtype: str):
    """è·å–ç‰¹å®šèŠ‚ç‚¹çš„è¯¦ç»†è§„èŒƒ"""
    spec = node_spec_registry.get_spec(node_type, subtype)
    if not spec:
        raise HTTPException(404, "æœªæ‰¾åˆ°èŠ‚ç‚¹è§„èŒƒ")

    return {
        "type": spec.node_type,
        "subtype": spec.subtype,
        "description": spec.description,
        "version": spec.version,
        "parameters": [
            {
                "name": p.name,
                "type": p.type.value,
                "required": p.required,
                "default_value": p.default_value,
                "description": p.description,
                "enum_values": p.enum_values,
                "validation_pattern": p.validation_pattern
            }
            for p in spec.parameters
        ],
        "input_ports": [
            {
                "name": p.name,
                "type": p.type,
                "required": p.required,
                "description": p.description,
                "max_connections": p.max_connections,
                "data_format": p.data_format.__dict__ if p.data_format else None,
                "validation_schema": p.validation_schema
            }
            for p in spec.input_ports
        ],
        "output_ports": [
            {
                "name": p.name,
                "type": p.type,
                "description": p.description,
                "max_connections": p.max_connections,
                "data_format": p.data_format.__dict__ if p.data_format else None,
                "validation_schema": p.validation_schema
            }
            for p in spec.output_ports
        ],
        "examples": spec.examples
    }

@router.post("/workflows/{workflow_id}/validate")
async def validate_workflow(workflow_id: str, workflow_data: dict):
    """éªŒè¯å·¥ä½œæµé…ç½®"""
    validator = WorkflowValidator()
    errors = validator.validate_workflow(workflow_data)

    return {
        "valid": len(errors) == 0,
        "errors": errors
    }

@router.post("/connections/validate")
async def validate_connection(
    source_node_type: str,
    source_subtype: str,
    source_port: str,
    target_node_type: str,
    target_subtype: str,
    target_port: str
):
    """éªŒè¯ç«¯å£è¿æ¥å…¼å®¹æ€§"""
    # æ¨¡æ‹ŸèŠ‚ç‚¹å¯¹è±¡
    source_node = type('Node', (), {
        'type': source_node_type,
        'subtype': source_subtype,
        'id': 'source'
    })()

    target_node = type('Node', (), {
        'type': target_node_type,
        'subtype': target_subtype,
        'id': 'target'
    })()

    errors = node_spec_registry.validate_connection(
        source_node, source_port, target_node, target_port
    )

    return {
        "compatible": len(errors) == 0,
        "errors": errors
    }
```

### å‰ç«¯é›†æˆ
```typescript
// å‰ç«¯ç°åœ¨å¯ä»¥è·å–ç»“æ„åŒ–çš„èŠ‚ç‚¹è§„èŒƒ
interface NodeSpec {
  type: string;
  subtype: string;
  description: string;
  parameters: ParameterDef[];
  input_ports: PortSpec[];
  output_ports: PortSpec[];
}

// åŸºäºè§„èŒƒè‡ªåŠ¨ç”Ÿæˆè¡¨å•
function generateNodeConfigForm(spec: NodeSpec) {
  return spec.parameters.map(param => {
    switch (param.type) {
      case 'enum':
        return <Select options={param.enum_values} required={param.required} />;
      case 'boolean':
        return <Checkbox defaultValue={param.default_value} />;
      case 'integer':
        return <NumberInput required={param.required} />;
      // ... å…¶ä»–ç±»å‹
    }
  });
}
```

## ğŸ“Š å®Œæ•´èŠ‚ç‚¹ç±»å‹è¦†ç›–

### è®¡åˆ’è§„èŒƒ

| èŠ‚ç‚¹ç±»å‹ | å­ç±»å‹ | çŠ¶æ€ |
|---------|--------|------|
| **TRIGGER_NODE** | MANUAL, WEBHOOK, CRON, CHAT, EMAIL, FORM, CALENDAR | âœ… å·²è®¡åˆ’ |
| **AI_AGENT_NODE** | ROUTER_AGENT, TASK_ANALYZER, DATA_INTEGRATOR, REPORT_GENERATOR, REMINDER_DECISION, WEEKLY_REPORT | âœ… å·²è®¡åˆ’ |
| **ACTION_NODE** | RUN_CODE, HTTP_REQUEST, PARSE_IMAGE, WEB_SEARCH, DATABASE_OPERATION, FILE_OPERATION, DATA_TRANSFORMATION | âœ… å·²è®¡åˆ’ |
| **FLOW_NODE** | IF, FILTER, LOOP, MERGE, SWITCH, WAIT | âœ… å·²è®¡åˆ’ |
| **TOOL_NODE** | GOOGLE_CALENDAR_MCP, NOTION_MCP, CALENDAR, EMAIL, HTTP, CODE_EXECUTION | âœ… å·²è®¡åˆ’ |
| **MEMORY_NODE** | SIMPLE, BUFFER, KNOWLEDGE, VECTOR_STORE, DOCUMENT, EMBEDDING | âœ… å·²è®¡åˆ’ |
| **HUMAN_IN_THE_LOOP_NODE** | GMAIL, SLACK, DISCORD, TELEGRAM, APP | âœ… å·²è®¡åˆ’ |
| **EXTERNAL_ACTION_NODE** | GITHUB, GOOGLE_CALENDAR, TRELLO, EMAIL, SLACK, API_CALL, WEBHOOK, NOTIFICATION | âš ï¸ éœ€è¦å®ç° |

## ğŸš€ å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„ä¸ç«¯å£ç³»ç»Ÿ (ç¬¬1-2å‘¨)

#### Protocol Bufferæ›´æ–°
- [ ] æ›´æ–° `workflow.proto` æ·»åŠ ç«¯å£å®šä¹‰å’Œæ•°æ®æ˜ å°„æ¶ˆæ¯
- [ ] é‡æ–°ç”ŸæˆPython protobufæ–‡ä»¶
- [ ] æ›´æ–°ç°æœ‰Nodeå’ŒConnectionæ¶ˆæ¯ç»“æ„

#### èŠ‚ç‚¹è§„èŒƒç³»ç»Ÿ
- [ ] åœ¨ `shared/node_specs/base.py` ä¸­åˆ›å»ºåŸºç¡€è§„èŒƒç±»ï¼ˆåŒ…å«ç«¯å£è§„èŒƒï¼‰
- [ ] åœ¨ `shared/node_specs/registry.py` ä¸­å®ç°æ³¨å†Œå™¨ç³»ç»Ÿ
- [ ] åœ¨ `shared/node_specs/validator.py` ä¸­åˆ›å»ºéªŒè¯æ¡†æ¶
- [ ] ä¸ºåŸºç¡€åŠŸèƒ½å»ºç«‹å•å…ƒæµ‹è¯•

#### ç«¯å£ç³»ç»Ÿé›†æˆ
- [ ] æ›´æ–°BaseNodeExecutorç±»é›†æˆç«¯å£è§„èŒƒ
- [ ] å®ç°ç«¯å£å…¼å®¹æ€§éªŒè¯é€»è¾‘
- [ ] åˆ›å»ºç«¯å£æ•°æ®éªŒè¯å™¨

### ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒèŠ‚ç‚¹è§„èŒƒå®šä¹‰ (ç¬¬3å‘¨)
- [ ] å®šä¹‰ TRIGGER_NODE å­ç±»å‹è§„èŒƒ
- [ ] å®šä¹‰ AI_AGENT_NODE å­ç±»å‹è§„èŒƒ
- [ ] å®šä¹‰ ACTION_NODE å­ç±»å‹è§„èŒƒ
- [ ] å®šä¹‰ FLOW_NODE å­ç±»å‹è§„èŒƒ

### ç¬¬ä¸‰é˜¶æ®µï¼šå…¶ä½™è§„èŒƒä¸æ•°æ®æ˜ å°„ (ç¬¬4å‘¨)
- [ ] å®šä¹‰ TOOL_NODE å­ç±»å‹è§„èŒƒ
- [ ] å®šä¹‰ MEMORY_NODE å­ç±»å‹è§„èŒƒ
- [ ] å®šä¹‰ HUMAN_IN_THE_LOOP_NODE å­ç±»å‹è§„èŒƒ
- [ ] å®ç°ç¼ºå¤±çš„ EXTERNAL_ACTION_NODE å­ç±»å‹

### ç¬¬å››é˜¶æ®µï¼šæ•°æ®æ˜ å°„ç³»ç»Ÿ (ç¬¬5å‘¨)
- [ ] å®ç°DataMappingProcessorç±»
- [ ] é›†æˆå­—æ®µæ˜ å°„ã€æ¨¡æ¿è½¬æ¢ã€è„šæœ¬è½¬æ¢
- [ ] æ›´æ–°ConnectionExecutoræ”¯æŒæ•°æ®æ˜ å°„
- [ ] æ·»åŠ æ•°æ®è½¬æ¢çš„ç›‘æ§å’Œè°ƒè¯•å·¥å…·

### ç¬¬äº”é˜¶æ®µï¼šå®Œæ•´é›†æˆ (ç¬¬6å‘¨)
- [ ] æ›´æ–° BaseNodeExecutor ä»¥ä½¿ç”¨è§„èŒƒ
- [ ] æ›´æ–°æ‰€æœ‰ç°æœ‰èŠ‚ç‚¹æ‰§è¡Œå™¨
- [ ] æ·»åŠ è§„èŒƒæŸ¥è¯¢çš„APIç«¯ç‚¹
- [ ] æ›´æ–°å·¥ä½œæµéªŒè¯å™¨ä»¥ä½¿ç”¨è§„èŒƒ
- [ ] åˆ›å»ºç°æœ‰å·¥ä½œæµçš„è¿ç§»æŒ‡å—

### ç¬¬å…­é˜¶æ®µï¼šæ–‡æ¡£å’Œæµ‹è¯• (ç¬¬7å‘¨)
- [ ] ç¼–å†™å…¨é¢çš„æ–‡æ¡£
- [ ] åˆ›å»ºè§„èŒƒç¤ºä¾‹å’Œæ¨¡æ¿
- [ ] æ·»åŠ é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
- å‚æ•°éªŒè¯é€»è¾‘
- ç«¯å£è§„èŒƒéªŒè¯
- æ³¨å†Œå™¨åŠŸèƒ½
- ä¸ªåˆ«èŠ‚ç‚¹è§„èŒƒ

### é›†æˆæµ‹è¯•
- ä½¿ç”¨è§„èŒƒçš„å·¥ä½œæµéªŒè¯
- APIç«¯ç‚¹åŠŸèƒ½
- èŠ‚ç‚¹æ‰§è¡Œå™¨é›†æˆ
- å‰ç«¯è¡¨å•ç”Ÿæˆ

### æµ‹è¯•æ•°æ®
```python
# æµ‹è¯•ç¤ºä¾‹
def test_router_agent_validation():
    node = create_test_node(
        type="AI_AGENT_NODE",
        subtype="ROUTER_AGENT",
        parameters={
            "prompt": "è·¯ç”±ç”¨æˆ·è¯·æ±‚",
            "routing_options": {"support": "tech", "sales": "sales"}
            # ç¼ºå°‘temperatureï¼ˆå¯é€‰ï¼Œæœ‰é»˜è®¤å€¼ï¼‰
        }
    )

    errors = node_spec_registry.validate_node(node)
    assert len(errors) == 0  # åº”è¯¥é€šè¿‡éªŒè¯

def test_missing_required_parameter():
    node = create_test_node(
        type="AI_AGENT_NODE",
        subtype="ROUTER_AGENT",
        parameters={}  # ç¼ºå°‘å¿…éœ€å‚æ•°
    )

    errors = node_spec_registry.validate_node(node)
    assert "ç¼ºå°‘å¿…éœ€å‚æ•°: prompt" in errors
    assert "ç¼ºå°‘å¿…éœ€å‚æ•°: routing_options" in errors
```

## ğŸ“ˆ ä¼˜åŠ¿

### å¯¹å¼€å‘è€…
1. **ç±»å‹å®‰å…¨**: å®Œæ•´çš„IDEæ”¯æŒå’Œè‡ªåŠ¨è¡¥å…¨
2. **æ¸…æ™°æ–‡æ¡£**: æ¯ä¸ªå‚æ•°å’Œç«¯å£éƒ½æœ‰æ–‡æ¡£
3. **éªŒè¯**: æ—©æœŸå‘ç°é…ç½®é”™è¯¯
4. **ä¸€è‡´æ€§**: æ‰€æœ‰èŠ‚ç‚¹ç±»å‹çš„æ ‡å‡†åŒ–æ–¹æ³•

### å¯¹ç”¨æˆ·
1. **æ›´å¥½çš„UI**: è‡ªåŠ¨ç”Ÿæˆå¸¦éªŒè¯çš„è¡¨å•
2. **æ¸…æ™°æŒ‡å¯¼**: å…¨é¢çš„å‚æ•°æè¿°å’Œç¤ºä¾‹
3. **é”™è¯¯é¢„é˜²**: åœ¨æ‰§è¡Œå‰æ•è·æ— æ•ˆé…ç½®
4. **å¯å‘ç°æ€§**: å®¹æ˜“æ¢ç´¢å¯ç”¨çš„èŠ‚ç‚¹ç±»å‹å’ŒåŠŸèƒ½

### å¯¹ç³»ç»Ÿ
1. **å¯ç»´æŠ¤æ€§**: é›†ä¸­çš„è§„èŒƒç®¡ç†
2. **å¯æ‰©å±•æ€§**: å®¹æ˜“æ·»åŠ æ–°èŠ‚ç‚¹ç±»å‹å’Œå‚æ•°
3. **ä¸€è‡´æ€§**: æ‰€æœ‰èŠ‚ç‚¹çš„ç»Ÿä¸€éªŒè¯å’Œè¡Œä¸º
4. **æ€§èƒ½**: å¿«é€Ÿçš„å†…å­˜è®¿é—®è§„èŒƒ

## ğŸ”„ è¿ç§»ç­–ç•¥

### å‘åå…¼å®¹
- ç°æœ‰å·¥ä½œæµç»§ç»­æ­£å¸¸å·¥ä½œ
- é€æ­¥è¿ç§»åˆ°ä½¿ç”¨è§„èŒƒ
- å¯¹ç°æœ‰APIæ— ç ´åæ€§æ›´æ”¹

### è¿ç§»æ­¥éª¤
1. **ä¸ç°æœ‰ä»£ç ä¸€èµ·éƒ¨ç½²è§„èŒƒ**
2. **æ›´æ–°éªŒè¯å™¨ä½¿ç”¨è§„èŒƒï¼ˆå¸¦å›é€€ï¼‰**
3. **æ·»åŠ åŸºäºè§„èŒƒçš„APIç«¯ç‚¹**
4. **æ›´æ–°å‰ç«¯ä½¿ç”¨æ–°ç«¯ç‚¹**
5. **å¼ƒç”¨æ—§çš„å‚æ•°éªŒè¯é€»è¾‘**

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

### å¼€å‘æŒ‡æ ‡
- [ ] 100%è¦†ç›–ç°æœ‰èŠ‚ç‚¹ç±»å‹/å­ç±»å‹
- [ ] å°‘äº100msè§„èŒƒæŸ¥æ‰¾æ€§èƒ½
- [ ] è¿ç§»æœŸé—´é›¶ç ´åæ€§æ›´æ”¹
- [ ] è§„èŒƒç³»ç»Ÿ90%+æµ‹è¯•è¦†ç›–ç‡

### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
- [ ] æ‰€æœ‰èŠ‚ç‚¹ç±»å‹çš„è‡ªåŠ¨ç”Ÿæˆè¡¨å•
- [ ] å…¨é¢çš„éªŒè¯é”™è¯¯æ¶ˆæ¯
- [ ] äº¤äº’å¼APIæ–‡æ¡£
- [ ] å¼€å‘è€…å…¥é—¨æ—¶é—´å‡å°‘

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**åˆ›å»ºæ—¶é—´**: 2025-01-28
**ä½œè€…**: Claude Code
**çŠ¶æ€**: è®¾è®¡é˜¶æ®µ
**ä¸‹æ¬¡å®¡æŸ¥**: 2025-02-04
